## Bubble sort 

**Bubble sort repeatedly compares adjacent elements and swaps them if they are in the wrong order. It is a simple algorithm to implement, but it is not very efficient.**

## Selection sort

**Selection sort repeatedly finds the smallest element in the unsorted portion of the array and swaps it with the leftmost unsorted element. It is more efficient than bubble sort, but it is still not very efficient for large arrays.**

## Insertion sort

**Insertion sort builds the sorted array one element at a time by inserting each unsorted element into its correct position in the sorted portion of the array. It is more efficient than bubble sort and selection sort, but it is still not very efficient for large arrays.**

## Merge sort

**Merge sort works by recursively dividing the unsorted array into smaller and smaller subarrays until each subarray contains only one element. The subarrays are then merged together in sorted order. Merge sort is a very efficient algorithm for large arrays.**

## Quick sort

**Quick sort works by choosing a pivot element in the unsorted array and then partitioning the array into two subarrays, one containing all the elements smaller than the pivot and the other containing all the elements larger than the pivot. Quick sort is a very efficient algorithm for large arrays.**

## Heap sort

**Heap sort works by building a binary heap data structure from the unsorted array. The binary heap is a tree-like data structure in which each parent node is greater than or equal to its child nodes. The heap is then repeatedly sorted by swapping the largest element with the smallest element and then rebuilding the heap. Heap sort is a very efficient algorithm for large arrays.**